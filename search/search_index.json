{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"RESPX Mock HTTPX with awesome request patterns and response side effects. QuickStart RESPX is a simple, yet powerful , utility for mocking out the HTTPX , and HTTP Core , libraries. Start by patching HTTPX , using respx.mock , then add request routes to mock responses . import httpx import respx from httpx import Response @respx . mock def test_example (): my_route = respx . get ( \"https://foo.bar/\" ) . mock ( return_value = Response ( 204 )) response = httpx . get ( \"https://foo.bar/\" ) assert my_route . called assert response . status_code == 204 Read the User Guide for a complete walk-through. pytest + httpx For a neater pytest experience, RESPX includes a respx_mock fixture for easy HTTPX mocking, along with an optional respx marker to fine-tune the mock settings . import httpx import pytest def test_default ( respx_mock ): respx_mock . get ( \"https://foo.bar/\" ) . mock ( return_value = httpx . Response ( 204 )) response = httpx . get ( \"https://foo.bar/\" ) assert response . status_code == 204 @pytest . mark . respx ( base_url = \"https://foo.bar\" ) def test_with_marker ( respx_mock ): respx_mock . get ( \"/baz/\" ) . mock ( return_value = httpx . Response ( 204 )) response = httpx . get ( \"https://foo.bar/baz/\" ) assert response . status_code == 204 Installation Install with pip: $ pip install respx Requires Python 3.6+ and HTTPX 0.18+. See Changelog for older HTTPX compatibility.","title":"Introduction"},{"location":"#quickstart","text":"RESPX is a simple, yet powerful , utility for mocking out the HTTPX , and HTTP Core , libraries. Start by patching HTTPX , using respx.mock , then add request routes to mock responses . import httpx import respx from httpx import Response @respx . mock def test_example (): my_route = respx . get ( \"https://foo.bar/\" ) . mock ( return_value = Response ( 204 )) response = httpx . get ( \"https://foo.bar/\" ) assert my_route . called assert response . status_code == 204 Read the User Guide for a complete walk-through.","title":"QuickStart"},{"location":"#pytest-httpx","text":"For a neater pytest experience, RESPX includes a respx_mock fixture for easy HTTPX mocking, along with an optional respx marker to fine-tune the mock settings . import httpx import pytest def test_default ( respx_mock ): respx_mock . get ( \"https://foo.bar/\" ) . mock ( return_value = httpx . Response ( 204 )) response = httpx . get ( \"https://foo.bar/\" ) assert response . status_code == 204 @pytest . mark . respx ( base_url = \"https://foo.bar\" ) def test_with_marker ( respx_mock ): respx_mock . get ( \"/baz/\" ) . mock ( return_value = httpx . Response ( 204 )) response = httpx . get ( \"https://foo.bar/baz/\" ) assert response . status_code == 204","title":"pytest + httpx"},{"location":"#installation","text":"Install with pip: $ pip install respx Requires Python 3.6+ and HTTPX 0.18+. See Changelog for older HTTPX compatibility.","title":"Installation"},{"location":"api/","text":"API Reference Router Configuration Creates a mock Router instance, ready to be used as decorator/manager for activation. respx. mock (assert_all_mocked=True, assert_all_called=True, base_url=None ) Parameters: assert_all_mocked - (optional) bool - default: True Asserts that all sent and captured HTTPX requests are routed and mocked. assert_all_called - (optional) bool - default: True Asserts that all added and mocked routes were called when exiting context. If disabled, all non-routed requests will be auto mocked with status code 200 . base_url - (optional) str Base URL to match, on top of each route specific pattern and/or side effect. Returns: Router pytest Use the @pytest.mark.respx(...) marker with these parameters to configure the respx_mock pytest fixture . NOTE When using the default mock router respx.mock , without settings , assert_all_called is disabled . .route() Adds a new, optionally named , Route with given patterns and/or lookups combined, using the AND operator. respx. route ( *patterns, name=None, **lookups ) Parameters: patterns - (optional) args One or more pattern objects. lookups - (optional) kwargs One or more pattern keyword lookups , given as <pattern>__<lookup>=value . name - (optional) str Name this route. Returns: Route .get(), .post(), ... HTTP method helpers to add routes, mimicking the HTTPX Helper Functions . respx. get ( url, name=None, **lookups ) respx. options (...) respx. head (...) respx. post (...) respx. put (...) respx. patch (...) respx. delete (...) Parameters: url - (optional) str | compiled regex | tuple (httpcore) | httpx.URL Request URL to match, full or partial , turned into a URL pattern. name - (optional) str Name this route. lookups - (optional) kwargs One or more pattern keyword lookups , given as <pattern>__<lookup>=value . Returns: Route respx . get ( \"https://example.org/\" , params = { \"foo\" : \"bar\" }, ... ) .request() respx. request ( method, url, name=None, **lookups ) Parameters: method - str Request HTTP method to match. url - (optional) str | compiled regex | tuple (httpcore) | httpx.URL Request URL to match, full or partial , turned into a URL pattern. name - (optional) str Name this route. lookups - (optional) kwargs One or more pattern keyword lookups , given as <pattern>__<lookup>=value . Returns: Route respx . request ( \"GET\" , \"https://example.org/\" , params = { \"foo\" : \"bar\" }, ... ) Route .mock() Mock a route's response or side effect. route. mock ( return_value=None, side_effect=None ) Parameters: return_value - (optional) Response HTTPX Response to mock and return. side_effect - (optional) Callable | Exception | Iterable of httpx.Response/Exception Side effect to call, exception to raise or stacked responses to respond with in order. Returns: Route .return_value Setter for the HTTPX Response to return. route. return_value = Response(204) .side_effect Setter for the side effect to trigger. route. side_effect = ... See route.mock() for valid side effect types. .respond() Shortcut for creating and mocking a HTTPX Response . route. respond ( status_code=200, headers=None, content=None, text=None, html=None, json=None, stream=None ) Parameters: status_code - (optional) int - default: 200 Response status code to mock. headers - (optional) dict Response headers to mock. content - (optional) bytes | str | iterable bytes Response raw content to mock. text - (optional) str Response text content to mock, with automatic content-type header added. html - (optional) str Response HTML content to mock, with automatic content-type header added. json - (optional) str | list | dict Response JSON content to mock, with automatic content-type header added. stream - (optional) Iterable[bytes] Response stream to mock. Returns: Route .pass_through() route. pass_through ( value=True ) Parameters: value - (optional) bool - default: True Mark route to pass through, sending matched requests to real server, e.g. don't mock . Returns: Route Response NOTE This is a partial reference for how to the instantiate the HTTPX Response class, e.g. not a RESPX class. httpx. Response ( status_code, headers=None, content=None, text=None, html=None, json=None, stream=None ) Parameters: status_code - int HTTP status code. headers - (optional) dict | httpx.Headers HTTP headers. content - (optional) bytes | str | Iterable[bytes] Raw content. text - (optional) str Text content, with automatic content-type header added. html - (optional) str HTML content, with automatic content-type header added. json - (optional) str | list | dict JSON content, with automatic content-type header added. stream - (optional) Iterable[bytes] Content stream . Patterns M() Creates a reusable pattern, combining multiple arguments using the AND operator. M ( *patterns, **lookups ) Parameters: patterns - (optional) args One or more pattern objects. lookups - (optional) kwargs One or more pattern keyword lookups , given as <pattern>__<lookup>=value . Returns: Pattern import respx from respx.patterns import M pattern = M ( host = \"example.org\" ) respx . route ( pattern ) See operators for advanced usage. Method Matches request HTTP method , using eq as default lookup. Key: method Lookups: eq , in respx . route ( method = \"GET\" ) respx . route ( method__in = [ \"PUT\" , \"PATCH\" ]) Scheme Matches request URL scheme , using eq as default lookup. Key: scheme Lookups: eq , in respx . route ( scheme = \"https\" ) respx . route ( scheme__in = [ \"http\" , \"https\" ]) Host Matches request URL host , using eq as default lookup. Key: host Lookups: eq , regex , in respx . route ( host = \"example.org\" ) respx . route ( host__regex = r \"example\\.(org|com)\" ) respx . route ( host__in = [ \"example.org\" , \"example.com\" ]) Port Matches request URL port , using eq as default lookup. Key: port Lookups: eq , in respx . route ( port = 8000 ) respx . route ( port__in = [ 2375 , 2376 ]) Path Matches request URL path , using eq as default lookup. Key: path Lookups: eq , regex , startswith , in respx . route ( path = \"/api/foobar/\" ) respx . route ( path__regex = r \"^/api/(?P<slug>\\w+)/\" ) respx . route ( path__startswith = \"/api/\" ) respx . route ( path__in = [ \"/api/v1/foo/\" , \"/api/v2/foo/\" ]) Params Matches request URL query params , using contains as default lookup. Key: params Lookups: contains , eq respx . route ( params = { \"foo\" : \"bar\" , \"ham\" : \"spam\" }) respx . route ( params = [( \"foo\" , \"bar\" ), ( \"ham\" , \"spam\" )]) respx . route ( params = (( \"foo\" , \"bar\" ), ( \"ham\" , \"spam\" ))) respx . route ( params = \"foo=bar&ham=spam\" ) URL Matches request URL . When no lookup is given, url works as a shorthand pattern, combining individual request URL parts, using the AND operator. Key: url Lookups: eq , regex , startswith respx . get ( \"//example.org/foo/\" ) # == M(host=\"example.org\", path=\"/foo/\") respx . get ( url__eq = \"https://example.org:8080/foobar/?ham=spam\" ) respx . get ( url__regex = r \"https://example.org/(?P<slug>\\w+)/\" ) respx . get ( url__startswith = \"https://example.org/api/\" ) respx . get ( \"all://*.example.org/foo/\" ) Content Matches request raw content , using eq as default lookup. Key: content Lookups: eq respx . post ( \"https://example.org/\" , content = \"foobar\" ) respx . post ( \"https://example.org/\" , content = b \"foobar\" ) Data Matches request form data , using eq as default lookup. Key: data Lookups: eq respx . post ( \"https://example.org/\" , data = { \"foo\" : \"bar\" }) JSON Matches request json content, using eq as default lookup. Key: json Lookups: eq respx . post ( \"https://example.org/\" , json = { \"foo\" : \"bar\" }) The json pattern also supports path traversing, i.e. json__<path>=<value> . respx . post ( \"https://example.org/\" , json__foobar__0__ham = \"spam\" ) httpx . post ( \"https://example.org/\" , json = { \"foobar\" : [{ \"ham\" : \"spam\" }]}) Headers Matches request headers , using contains as default lookup. Key: headers Lookups: contains , eq respx . route ( headers = { \"foo\" : \"bar\" , \"ham\" : \"spam\" }) respx . route ( headers = [( \"foo\" , \"bar\" ), ( \"ham\" , \"spam\" )]) Cookies Matches request cookie header , using contains as default lookup. Key: cookies Lookups: contains , eq respx . route ( cookies = { \"foo\" : \"bar\" , \"ham\" : \"spam\" }) respx . route ( cookies = [( \"foo\" , \"bar\" ), ( \"ham\" , \"spam\" )]) Lookups eq M ( path = \"/foo/bar/\" ) M ( path__eq = \"/foo/bar/\" ) contains Case-sensitive containment test. M ( params__contains = { \"id\" : \"123\" }) in Case-sensitive within test. M ( method__in = [ \"PUT\" , \"PATCH\" ]) regex M ( path__regex = r \"^/api/(?P<slug>\\w+)/\" ) startswith Case-sensitive starts-with. M ( path__startswith = \"/api/\" ) Operators Patterns can be combined using bitwise operators, creating new patterns. AND (&) Combines two Pattern s using and operator. M ( scheme = \"http\" ) & M ( host = \"example.org\" ) OR (&) Combines two Pattern s using or operator. M ( method = \"PUT\" ) | M ( method = \"PATCH\" ) INVERT (~) Inverts a Pattern match. ~ M ( params = { \"foo\" : \"bar\" })","title":"API Reference"},{"location":"api/#api-reference","text":"","title":"API Reference"},{"location":"api/#router","text":"","title":"Router"},{"location":"api/#configuration","text":"Creates a mock Router instance, ready to be used as decorator/manager for activation. respx. mock (assert_all_mocked=True, assert_all_called=True, base_url=None ) Parameters: assert_all_mocked - (optional) bool - default: True Asserts that all sent and captured HTTPX requests are routed and mocked. assert_all_called - (optional) bool - default: True Asserts that all added and mocked routes were called when exiting context. If disabled, all non-routed requests will be auto mocked with status code 200 . base_url - (optional) str Base URL to match, on top of each route specific pattern and/or side effect. Returns: Router pytest Use the @pytest.mark.respx(...) marker with these parameters to configure the respx_mock pytest fixture . NOTE When using the default mock router respx.mock , without settings , assert_all_called is disabled .","title":"Configuration"},{"location":"api/#route","text":"Adds a new, optionally named , Route with given patterns and/or lookups combined, using the AND operator. respx. route ( *patterns, name=None, **lookups ) Parameters: patterns - (optional) args One or more pattern objects. lookups - (optional) kwargs One or more pattern keyword lookups , given as <pattern>__<lookup>=value . name - (optional) str Name this route. Returns: Route","title":".route()"},{"location":"api/#get-post","text":"HTTP method helpers to add routes, mimicking the HTTPX Helper Functions . respx. get ( url, name=None, **lookups ) respx. options (...) respx. head (...) respx. post (...) respx. put (...) respx. patch (...) respx. delete (...) Parameters: url - (optional) str | compiled regex | tuple (httpcore) | httpx.URL Request URL to match, full or partial , turned into a URL pattern. name - (optional) str Name this route. lookups - (optional) kwargs One or more pattern keyword lookups , given as <pattern>__<lookup>=value . Returns: Route respx . get ( \"https://example.org/\" , params = { \"foo\" : \"bar\" }, ... )","title":".get(), .post(), ..."},{"location":"api/#request","text":"respx. request ( method, url, name=None, **lookups ) Parameters: method - str Request HTTP method to match. url - (optional) str | compiled regex | tuple (httpcore) | httpx.URL Request URL to match, full or partial , turned into a URL pattern. name - (optional) str Name this route. lookups - (optional) kwargs One or more pattern keyword lookups , given as <pattern>__<lookup>=value . Returns: Route respx . request ( \"GET\" , \"https://example.org/\" , params = { \"foo\" : \"bar\" }, ... )","title":".request()"},{"location":"api/#route_1","text":"","title":"Route"},{"location":"api/#mock","text":"Mock a route's response or side effect. route. mock ( return_value=None, side_effect=None ) Parameters: return_value - (optional) Response HTTPX Response to mock and return. side_effect - (optional) Callable | Exception | Iterable of httpx.Response/Exception Side effect to call, exception to raise or stacked responses to respond with in order. Returns: Route","title":".mock()"},{"location":"api/#return_value","text":"Setter for the HTTPX Response to return. route. return_value = Response(204)","title":".return_value"},{"location":"api/#side_effect","text":"Setter for the side effect to trigger. route. side_effect = ... See route.mock() for valid side effect types.","title":".side_effect"},{"location":"api/#respond","text":"Shortcut for creating and mocking a HTTPX Response . route. respond ( status_code=200, headers=None, content=None, text=None, html=None, json=None, stream=None ) Parameters: status_code - (optional) int - default: 200 Response status code to mock. headers - (optional) dict Response headers to mock. content - (optional) bytes | str | iterable bytes Response raw content to mock. text - (optional) str Response text content to mock, with automatic content-type header added. html - (optional) str Response HTML content to mock, with automatic content-type header added. json - (optional) str | list | dict Response JSON content to mock, with automatic content-type header added. stream - (optional) Iterable[bytes] Response stream to mock. Returns: Route","title":".respond()"},{"location":"api/#pass_through","text":"route. pass_through ( value=True ) Parameters: value - (optional) bool - default: True Mark route to pass through, sending matched requests to real server, e.g. don't mock . Returns: Route","title":".pass_through()"},{"location":"api/#response","text":"NOTE This is a partial reference for how to the instantiate the HTTPX Response class, e.g. not a RESPX class. httpx. Response ( status_code, headers=None, content=None, text=None, html=None, json=None, stream=None ) Parameters: status_code - int HTTP status code. headers - (optional) dict | httpx.Headers HTTP headers. content - (optional) bytes | str | Iterable[bytes] Raw content. text - (optional) str Text content, with automatic content-type header added. html - (optional) str HTML content, with automatic content-type header added. json - (optional) str | list | dict JSON content, with automatic content-type header added. stream - (optional) Iterable[bytes] Content stream .","title":"Response"},{"location":"api/#patterns","text":"","title":"Patterns"},{"location":"api/#m","text":"Creates a reusable pattern, combining multiple arguments using the AND operator. M ( *patterns, **lookups ) Parameters: patterns - (optional) args One or more pattern objects. lookups - (optional) kwargs One or more pattern keyword lookups , given as <pattern>__<lookup>=value . Returns: Pattern import respx from respx.patterns import M pattern = M ( host = \"example.org\" ) respx . route ( pattern ) See operators for advanced usage.","title":"M()"},{"location":"api/#method","text":"Matches request HTTP method , using eq as default lookup. Key: method Lookups: eq , in respx . route ( method = \"GET\" ) respx . route ( method__in = [ \"PUT\" , \"PATCH\" ])","title":"Method"},{"location":"api/#scheme","text":"Matches request URL scheme , using eq as default lookup. Key: scheme Lookups: eq , in respx . route ( scheme = \"https\" ) respx . route ( scheme__in = [ \"http\" , \"https\" ])","title":"Scheme"},{"location":"api/#host","text":"Matches request URL host , using eq as default lookup. Key: host Lookups: eq , regex , in respx . route ( host = \"example.org\" ) respx . route ( host__regex = r \"example\\.(org|com)\" ) respx . route ( host__in = [ \"example.org\" , \"example.com\" ])","title":"Host"},{"location":"api/#port","text":"Matches request URL port , using eq as default lookup. Key: port Lookups: eq , in respx . route ( port = 8000 ) respx . route ( port__in = [ 2375 , 2376 ])","title":"Port"},{"location":"api/#path","text":"Matches request URL path , using eq as default lookup. Key: path Lookups: eq , regex , startswith , in respx . route ( path = \"/api/foobar/\" ) respx . route ( path__regex = r \"^/api/(?P<slug>\\w+)/\" ) respx . route ( path__startswith = \"/api/\" ) respx . route ( path__in = [ \"/api/v1/foo/\" , \"/api/v2/foo/\" ])","title":"Path"},{"location":"api/#params","text":"Matches request URL query params , using contains as default lookup. Key: params Lookups: contains , eq respx . route ( params = { \"foo\" : \"bar\" , \"ham\" : \"spam\" }) respx . route ( params = [( \"foo\" , \"bar\" ), ( \"ham\" , \"spam\" )]) respx . route ( params = (( \"foo\" , \"bar\" ), ( \"ham\" , \"spam\" ))) respx . route ( params = \"foo=bar&ham=spam\" )","title":"Params"},{"location":"api/#url","text":"Matches request URL . When no lookup is given, url works as a shorthand pattern, combining individual request URL parts, using the AND operator. Key: url Lookups: eq , regex , startswith respx . get ( \"//example.org/foo/\" ) # == M(host=\"example.org\", path=\"/foo/\") respx . get ( url__eq = \"https://example.org:8080/foobar/?ham=spam\" ) respx . get ( url__regex = r \"https://example.org/(?P<slug>\\w+)/\" ) respx . get ( url__startswith = \"https://example.org/api/\" ) respx . get ( \"all://*.example.org/foo/\" )","title":"URL"},{"location":"api/#content","text":"Matches request raw content , using eq as default lookup. Key: content Lookups: eq respx . post ( \"https://example.org/\" , content = \"foobar\" ) respx . post ( \"https://example.org/\" , content = b \"foobar\" )","title":"Content"},{"location":"api/#data","text":"Matches request form data , using eq as default lookup. Key: data Lookups: eq respx . post ( \"https://example.org/\" , data = { \"foo\" : \"bar\" })","title":"Data"},{"location":"api/#json","text":"Matches request json content, using eq as default lookup. Key: json Lookups: eq respx . post ( \"https://example.org/\" , json = { \"foo\" : \"bar\" }) The json pattern also supports path traversing, i.e. json__<path>=<value> . respx . post ( \"https://example.org/\" , json__foobar__0__ham = \"spam\" ) httpx . post ( \"https://example.org/\" , json = { \"foobar\" : [{ \"ham\" : \"spam\" }]})","title":"JSON"},{"location":"api/#headers","text":"Matches request headers , using contains as default lookup. Key: headers Lookups: contains , eq respx . route ( headers = { \"foo\" : \"bar\" , \"ham\" : \"spam\" }) respx . route ( headers = [( \"foo\" , \"bar\" ), ( \"ham\" , \"spam\" )])","title":"Headers"},{"location":"api/#cookies","text":"Matches request cookie header , using contains as default lookup. Key: cookies Lookups: contains , eq respx . route ( cookies = { \"foo\" : \"bar\" , \"ham\" : \"spam\" }) respx . route ( cookies = [( \"foo\" , \"bar\" ), ( \"ham\" , \"spam\" )])","title":"Cookies"},{"location":"api/#lookups","text":"","title":"Lookups"},{"location":"api/#eq","text":"M ( path = \"/foo/bar/\" ) M ( path__eq = \"/foo/bar/\" )","title":"eq"},{"location":"api/#contains","text":"Case-sensitive containment test. M ( params__contains = { \"id\" : \"123\" })","title":"contains"},{"location":"api/#in","text":"Case-sensitive within test. M ( method__in = [ \"PUT\" , \"PATCH\" ])","title":"in"},{"location":"api/#regex","text":"M ( path__regex = r \"^/api/(?P<slug>\\w+)/\" )","title":"regex"},{"location":"api/#startswith","text":"Case-sensitive starts-with. M ( path__startswith = \"/api/\" )","title":"startswith"},{"location":"api/#operators","text":"Patterns can be combined using bitwise operators, creating new patterns.","title":"Operators"},{"location":"api/#and","text":"Combines two Pattern s using and operator. M ( scheme = \"http\" ) & M ( host = \"example.org\" )","title":"AND (&amp;)"},{"location":"api/#or","text":"Combines two Pattern s using or operator. M ( method = \"PUT\" ) | M ( method = \"PATCH\" )","title":"OR (&amp;)"},{"location":"api/#invert","text":"Inverts a Pattern match. ~ M ( params = { \"foo\" : \"bar\" })","title":"INVERT (~)"},{"location":"examples/","text":"Test Case Examples pytest Built-in Fixture RESPX includes the respx_mock pytest httpx fixture . import httpx def test_fixture ( respx_mock ): respx_mock . get ( \"https://foo.bar/\" ) . mock ( return_value = httpx . Response ( 204 )) response = httpx . get ( \"https://foo.bar/\" ) assert response . status_code == 204 Built-in Marker To configure the respx_mock fixture, use the respx marker . import httpx import pytest @pytest . mark . respx ( base_url = \"https://foo.bar\" ) def test_configured_fixture ( respx_mock ): respx_mock . get ( \"/baz/\" ) . mock ( return_value = httpx . Response ( 204 )) response = httpx . get ( \"https://foo.bar/baz/\" ) assert response . status_code == 204 See router configuration reference for more details. Custom Fixtures # conftest.py import pytest import respx from httpx import Response @pytest . fixture def mocked_api (): with respx . mock ( base_url = \"https://foo.bar\" , assert_all_called = False ) as respx_mock : users_route = respx_mock . get ( \"/users/\" , name = \"list_users\" ) users_route . return_value = Response ( 200 , json = []) ... yield respx_mock # test_api.py import httpx def test_list_users ( mocked_api ): response = httpx . get ( \"https://foo.bar/users/\" ) assert response . status_code == 200 assert response . json () == [] assert mocked_api [ \"list_users\" ] . called Session Scoped Fixtures If a session scoped RESPX fixture is used in an async context, you also need to broaden the pytest-asyncio event_loop fixture. You can use the session_event_loop utility for this. # conftest.py import pytest import respx from respx.fixtures import session_event_loop as event_loop # noqa: F401 @pytest . fixture ( scope = \"session\" ) async def mocked_api ( event_loop ): # noqa: F811 async with respx . mock ( base_url = \"https://foo.bar\" ) as respx_mock : ... yield respx_mock Async Test Cases import httpx import respx @respx . mock @pytest . mark . asyncio async def test_async_decorator (): async with httpx . AsyncClient () as client : route = respx . get ( \"https://example.org/\" ) response = await client . get ( \"https://example.org/\" ) assert route . called assert response . status_code == 200 @pytest . mark . asyncio async def test_async_ctx_manager (): async with respx . mock : async with httpx . AsyncClient () as client : route = respx . get ( \"https://example.org/\" ) response = await client . get ( \"https://example.org/\" ) assert route . called assert response . status_code == 200 unittest SetUp & TearDown # testcases.py import respx from httpx import Response class MockedAPIMixin : @classmethod def setUpClass ( cls ): cls . mocked_api = respx . mock ( base_url = \"https://foo.bar\" , assert_all_called = False ) users_route = cls . mocked_api . get ( \"/users/\" , name = \"list_users\" ) users_route . return_value = Response ( 200 , json = []) ... def setUp ( self ): self . mocked_api . start () def tearDown ( self ): self . mocked_api . stop () # test_api.py import httpx import unittest from .testcases import MockedAPIMixin class APITestCase ( MockedAPIMixin , unittest . TestCase ): def test_list_users ( self ): response = httpx . get ( \"https://foo.bar/users/\" ) self . assertEqual ( response . status_code , 200 ) self . assertListEqual ( response . json (), []) self . assertTrue ( self . mocked_api [ \"list_users\" ] . called ) Async Test Cases import asynctest import httpx import respx class MyTestCase ( asynctest . TestCase ): @respx . mock async def test_async_decorator ( self ): async with httpx . AsyncClient () as client : route = respx . get ( \"https://example.org/\" ) response = await client . get ( \"https://example.org/\" ) assert route . called assert response . status_code == 200 async def test_async_ctx_manager ( self ): async with respx . mock : async with httpx . AsyncClient () as client : route = respx . get ( \"https://example.org/\" ) response = await client . get ( \"https://example.org/\" ) assert route . called assert response . status_code == 200","title":"Test Case Examples"},{"location":"examples/#test-case-examples","text":"","title":"Test Case Examples"},{"location":"examples/#pytest","text":"","title":"pytest"},{"location":"examples/#built-in-fixture","text":"RESPX includes the respx_mock pytest httpx fixture . import httpx def test_fixture ( respx_mock ): respx_mock . get ( \"https://foo.bar/\" ) . mock ( return_value = httpx . Response ( 204 )) response = httpx . get ( \"https://foo.bar/\" ) assert response . status_code == 204","title":"Built-in Fixture"},{"location":"examples/#built-in-marker","text":"To configure the respx_mock fixture, use the respx marker . import httpx import pytest @pytest . mark . respx ( base_url = \"https://foo.bar\" ) def test_configured_fixture ( respx_mock ): respx_mock . get ( \"/baz/\" ) . mock ( return_value = httpx . Response ( 204 )) response = httpx . get ( \"https://foo.bar/baz/\" ) assert response . status_code == 204 See router configuration reference for more details.","title":"Built-in Marker"},{"location":"examples/#custom-fixtures","text":"# conftest.py import pytest import respx from httpx import Response @pytest . fixture def mocked_api (): with respx . mock ( base_url = \"https://foo.bar\" , assert_all_called = False ) as respx_mock : users_route = respx_mock . get ( \"/users/\" , name = \"list_users\" ) users_route . return_value = Response ( 200 , json = []) ... yield respx_mock # test_api.py import httpx def test_list_users ( mocked_api ): response = httpx . get ( \"https://foo.bar/users/\" ) assert response . status_code == 200 assert response . json () == [] assert mocked_api [ \"list_users\" ] . called Session Scoped Fixtures If a session scoped RESPX fixture is used in an async context, you also need to broaden the pytest-asyncio event_loop fixture. You can use the session_event_loop utility for this. # conftest.py import pytest import respx from respx.fixtures import session_event_loop as event_loop # noqa: F401 @pytest . fixture ( scope = \"session\" ) async def mocked_api ( event_loop ): # noqa: F811 async with respx . mock ( base_url = \"https://foo.bar\" ) as respx_mock : ... yield respx_mock","title":"Custom Fixtures"},{"location":"examples/#async-test-cases","text":"import httpx import respx @respx . mock @pytest . mark . asyncio async def test_async_decorator (): async with httpx . AsyncClient () as client : route = respx . get ( \"https://example.org/\" ) response = await client . get ( \"https://example.org/\" ) assert route . called assert response . status_code == 200 @pytest . mark . asyncio async def test_async_ctx_manager (): async with respx . mock : async with httpx . AsyncClient () as client : route = respx . get ( \"https://example.org/\" ) response = await client . get ( \"https://example.org/\" ) assert route . called assert response . status_code == 200","title":"Async Test Cases"},{"location":"examples/#unittest","text":"","title":"unittest"},{"location":"examples/#setup-teardown","text":"# testcases.py import respx from httpx import Response class MockedAPIMixin : @classmethod def setUpClass ( cls ): cls . mocked_api = respx . mock ( base_url = \"https://foo.bar\" , assert_all_called = False ) users_route = cls . mocked_api . get ( \"/users/\" , name = \"list_users\" ) users_route . return_value = Response ( 200 , json = []) ... def setUp ( self ): self . mocked_api . start () def tearDown ( self ): self . mocked_api . stop () # test_api.py import httpx import unittest from .testcases import MockedAPIMixin class APITestCase ( MockedAPIMixin , unittest . TestCase ): def test_list_users ( self ): response = httpx . get ( \"https://foo.bar/users/\" ) self . assertEqual ( response . status_code , 200 ) self . assertListEqual ( response . json (), []) self . assertTrue ( self . mocked_api [ \"list_users\" ] . called )","title":"SetUp &amp; TearDown"},{"location":"examples/#async-test-cases_1","text":"import asynctest import httpx import respx class MyTestCase ( asynctest . TestCase ): @respx . mock async def test_async_decorator ( self ): async with httpx . AsyncClient () as client : route = respx . get ( \"https://example.org/\" ) response = await client . get ( \"https://example.org/\" ) assert route . called assert response . status_code == 200 async def test_async_ctx_manager ( self ): async with respx . mock : async with httpx . AsyncClient () as client : route = respx . get ( \"https://example.org/\" ) response = await client . get ( \"https://example.org/\" ) assert route . called assert response . status_code == 200","title":"Async Test Cases"},{"location":"guide/","text":"User Guide RESPX is a mock router, capturing requests sent by HTTPX , mocking their responses. Inspired by the flexible query API of the Django ORM, requests are filtered and matched against routes and their request patterns and lookups . Request patterns are bits of the request, like host method path etc, with given lookup values, combined using bitwise operators to form a Route , i.e. respx.route(path__regex=...) A captured request, matching a Route , resolves to a mocked httpx.Response , or triggers a given side effect . To skip mocking a specific request, a route can be marked to pass through . Mock HTTPX To patch HTTPX , and activate the router, use the respx.mock decorator or context manager. Using the Decorator import httpx import respx @respx . mock def test_decorator (): my_route = respx . get ( \"https://example.org/\" ) response = httpx . get ( \"https://example.org/\" ) assert my_route . called assert response . status_code == 200 Using the Context Manager import httpx import respx def test_ctx_manager (): with respx . mock : my_route = respx . get ( \"https://example.org/\" ) response = httpx . get ( \"https://example.org/\" ) assert my_route . called assert response . status_code == 200 Router Settings The RESPX router can be configured with built-in assertion checks and an optional base URL . By configuring, a nested router is created, and the settings are locally bound to the routes added. When decorating a test case with a configured router, the test function will receive the router instance as a respx_mock argument. @respx . mock ( assert_all_mocked = False ) def test_something ( respx_mock ): ... See router configuration reference for more details. Settings Examples: @respx . mock ( assert_all_called = False ) def test_something ( respx_mock ): respx_mock . get ( \"https://example.org/\" ) respx_mock . get ( \"https://some.url/\" ) # Not called, yet not asserted response = httpx . get ( \"https://example.org/\" ) assert response . status_code == 200 with respx . mock ( assert_all_mocked = False ) as respx_mock : response = httpx . get ( \"https://example.org/\" ) # Not mocked, yet not asserted assert response . status_code == 200 Base URL When adding a lot of routes, sharing the same domain/prefix, you can configure the router with a base_url to be used for added routes. import httpx import respx from httpx import Response @respx . mock ( base_url = \"https://example.org/api/\" ) async def test_something ( respx_mock ): async with httpx . AsyncClient ( base_url = \"https://example.org/api/\" ) as client : respx_mock . get ( \"/baz/\" ) . mock ( return_value = Response ( 200 , text = \"Baz\" )) response = await client . get ( \"/baz/\" ) assert response . text == \"Baz\" Routing Requests The easiest way to add routes is to use the HTTP Method helpers. For full control over the request pattern matching, use the route API. HTTP Method Helpers Each HTTP method has a helper function ( get , options , head , post , put , patch , delete ), shortcutting the route API. my_route = respx . get ( \"https://example.org/\" , params = { \"foo\" : \"bar\" }) response = httpx . get ( \"https://example.org/\" , params = { \"foo\" : \"bar\" }) assert my_route . called assert response . status_code == 200 See .get(), .post(), ... helpers reference for more details. Route API Patterns With the route API, you define a combined pattern to match, capturing a sent request. my_route = respx . route ( method = \"GET\" , host = \"example.org\" , path = \"/foobar/\" ) response = httpx . get ( \"https://example.org/foobar/\" ) assert my_route . called assert response . status_code == 200 See .route() reference for more details. Lookups Each pattern has a default lookup. To specify what lookup to use, add a __<lookup> suffix. respx . route ( method__in = [ \"PUT\" , \"PATCH\" ]) Combining Patterns For even more flexability, you can define combined patterns using the M() object , together with bitwise operators ( & , |, ~ ), creating a reusable pattern. hosts_pattern = M ( host = \"example.org\" ) | M ( host = \"example.com\" ) my_route = respx . route ( hosts_pattern , method = \"GET\" , path = \"/foo/\" ) response = httpx . get ( \"http://example.org/foo/\" ) assert response . status_code == 200 assert my_route . called response = httpx . get ( \"https://example.com/foo/\" ) assert response . status_code == 200 assert my_route . call_count == 2 NOTE M(url=\"//example.org/foobar/\") is equal to M(host=\"example.org\") & M(path=\"/foobar/\") Named Routes Routes can be named when added, and later accessed through the respx.routes mapping. This is useful when a route is added outside the test case, e.g. access or assert route calls. import httpx import respx # Added somewhere else respx . get ( \"https://example.org/\" , name = \"home\" ) @respx . mock def test_route_call (): httpx . get ( \"https://example.org/\" ) assert respx . routes [ \"home\" ] . called assert respx . routes [ \"home\" ] . call_count == 1 last_home_response = respx . routes [ \"home\" ] . calls . last . response assert last_home_response . status_code == 200 Nested Routers As described under settings , a nested router is created when calling respx.mock(...) . Nested routers are useful when mocking multiple remote APIs, allowing grouped routes per API, and to be mocked individually and reused across tests. Use the nested router as decorator or context manager to patch HTTPX and activate the routes. import httpx import respx from httpx import Response api_mock = respx . mock ( assert_all_called = False ) api_mock . route ( url = \"https://api.foo.bar/baz/\" , name = \"baz\" , ) . mock ( return_value = Response ( 200 , json = { \"name\" : \"baz\" }), ) ... @api_mock def test_decorator (): response = httpx . get ( \"https://api.foo.bar/baz/\" ) assert response . status_code == 200 assert response . json () == { \"name\" : \"baz\" } assert api_mock [ \"baz\" ] . called def test_ctx_manager (): with api_mock : ... NOTE Named routes in a nested router can be directly accessed via my_mock_router[<route name>] Mocking Responses To mock a route response, use <route>.mock(...) to either... set the httpx.Response to be returned . set a side effect to be triggered. Mock a Response Create a mocked HTTPX Response object and pass it as return_value . respx . get ( \"https://example.org/\" ) . mock ( return_value = Response ( 204 )) See .mock() reference for more details. You can also use the <route>.return_value setter . route = respx . get ( \"https://example.org/\" ) route . return_value = Response ( 200 , json = { \"foo\" : \"bar\" }) Mock with a Side Effect RESPX side effects works just like the python Mock side effects. It can either be a function to call, an exception to raise, or an iterable of responses/exceptions to respond with in order, for repeated requests. respx . get ( \"https://example.org/\" ) . mock ( side_effect =... ) You can also use the <route>.side_effect setter . route = respx . get ( \"https://example.org/\" ) route . side_effect = ... Functions Function side effects will be called with the captured request argument, and should either... return a mocked Response . raise an Exception to simulate a request error. return None to treat the route as a non-match , continuing testing further routes. return the input Request to pass through . import httpx import respx def my_side_effect ( request ): return httpx . Response ( 201 ) @respx . mock def test_side_effect (): respx . post ( \"https://example.org/\" ) . mock ( side_effect = my_side_effect ) response = httpx . post ( \"https://example.org/\" ) assert response . status_code == 201 If any of the route patterns are using a regex lookup , containing named groups , the regex groups will be passed as kwargs to the side effect . import httpx import respx def my_side_effect ( request , slug ): return httpx . Response ( 200 , json = { \"slug\" : slug }) @respx . mock def test_side_effect_kwargs (): route = respx . route ( url__regex = r \"https://example.org/(?P<slug>\\w+)/\" ) route . side_effect = my_side_effect response = httpx . get ( \"https://example.org/foobar/\" ) assert response . status_code == 200 assert response . json () == { \"slug\" : \"foobar\" } A route can even decorate the function to be used as side effect . import httpx import rexpx @respx . route ( url__regex = r \"https://example.org/(?P<user>\\w+)/\" , name = \"user\" ) def user_api ( request , user ): return httpx . Response ( 200 , json = { \"user\" : user }) @respx . mock def test_user_api (): response = httpx . get ( \"https://example.org/lundberg/\" ) assert response . status_code == 200 assert response . json () == { \"user\" : \"lundberg\" } assert respx . routes [ \"user\" ] . called Exceptions To simulate a request error, pass a httpx.HTTPError subclass , or any Exception as side effect . import httpx import respx @respx . mock def test_connection_error (): respx . get ( \"https://example.org/\" ) . mock ( side_effect = httpx . ConnectError ) with pytest . raises ( httpx . ConnectError ): httpx . get ( \"https://example.org/\" ) Iterable If the side effect is an iterable , each repeated request will get the next Response returned, or exception raised, from the iterable. import httpx import respx @respx . mock def test_stacked_responses (): route = respx . get ( \"https://example.org/\" ) route . side_effect = [ httpx . Response ( 404 ), httpx . Response ( 200 ), ] response1 = httpx . get ( \"https://example.org/\" ) response2 = httpx . get ( \"https://example.org/\" ) assert response1 . status_code == 404 assert response2 . status_code == 200 assert route . call_count == 2 Modulo Shortcut For simple mocking, a quick way is to use the python modulo ( % ) operator to mock the response. The right-hand modulo argument can either be ... An int representing the status_code to mock: respx . get ( \"https://example.org/\" ) % 204 response = httpx . get ( \"https://example.org/\" ) assert response . status_code == 204 A dict used as kwargs to create a mocked HTTPX Response , with status code 200 by default: respx . get ( \"https://example.org/\" ) % dict ( json = { \"foo\" : \"bar\" }) response = httpx . get ( \"https://example.org/\" ) assert response . status_code == 200 assert response . json () == { \"foo\" : \"bar\" } A HTTPX Response object: respx . get ( \"https://example.org/\" ) % Response ( 418 ) response = httpx . get ( \"https://example.org/\" ) assert response . status_code == httpx . codes . IM_A_TEAPOT Rollback When exiting a decorated test case, or context manager , the routes and their mocked values, i.e. return_value and side_effect , will be rolled back and restored to their initial state. This means that you can safely modify existing routes, or add new ones, within a test case, without affecting other tests. import httpx import respx # Initial routes mock_router = respx . mock ( base_url = \"https://example.org\" ) mock_router . get ( path__regex = \"/user/(?P<pk>\\d+)/\" , name = \"user\" ) % 404 ... @mock_router def test_user_exists (): # This change will be rolled back after this test case mock_router [ \"user\" ] . return_value = httpx . Response ( 200 ) response = httpx . get ( \"https://example.org/user/123/\" ) assert response . status_code == 200 @mock_router def test_user_not_found (): response = httpx . get ( \"https://example.org/user/123/\" ) assert response . status_code == 404 Pass Through If you want a route to not capture and mock a request response, use .pass_through() . import httpx import respx @respx . mock def test_remote_response (): respx . route ( host = \"localhost\" ) . pass_through () response = httpx . get ( \"http://localhost:8000/\" ) # respose from server See .pass_through() reference for more details. Mock without patching HTTPX The RESPX implements the HTTP Core transport interface. If you don't need to patch HTTPX , pass a MockTransport as transport , when instantiating your HTTPX client, or alike. import httpx import respx from respx.transports import MockTransport router = respx . Router () router . post ( \"https://example.org/\" ) % 404 def test_client (): mock_transport = MockTransport ( router = router ) with httpx . Client ( transport = mock_transport ) as client : response = client . post ( \"https://example.org/\" ) assert response . status_code == 404 Hint You can use RESPX not only to mock out HTTPX , but actually mock any library using HTTP Core transports. Call History The respx API includes a .calls object, containing captured ( request , response ) named tuples and MagicMock's bells and whistles , i.e. call_count , assert_called etc. Asserting calls assert respx . calls . called assert respx . calls . call_count == 1 respx . calls . assert_called () respx . calls . assert_not_called () respx . calls . assert_called_once () Retreiving mocked calls A matched and mocked Call can be retrived from call history, by either unpacking... request , response = respx . calls . last request , response = respx . calls [ - 2 ] # by call order ...or by accessing request or response directly... last_request = respx . calls . last . request assert respx . calls . last . response . status_code == 200 Local route calls Each Route object has its own .calls , along with .called and .call_count shortcuts. import httpx import respx @respx . mock def test_route_call_stats (): route = respx . post ( \"https://example.org/baz/\" ) % 201 httpx . post ( \"https://example.org/baz/\" ) assert route . calls . last . request . url . path == \"/baz/\" assert route . calls . last . response . status_code == 201 assert route . called assert route . call_count == 1 route . calls . assert_called_once () Reset History The call history will automatically reset when exiting mocked context, i.e. leaving a decorated test case, or context manager scope. To manually reset call stats during a test case, use respx.reset() or <your_router>.reset() . import httpx import respx @respx . mock def test_reset (): respx . post ( \"https://foo.bar/baz/\" ) httpx . post ( \"https://foo.bar/baz/\" ) assert respx . calls . call_count == 1 respx . calls . assert_called_once () respx . reset () assert len ( respx . calls ) == 0 assert respx . calls . call_count == 0 respx . calls . assert_not_called ()","title":"User Guide"},{"location":"guide/#user-guide","text":"RESPX is a mock router, capturing requests sent by HTTPX , mocking their responses. Inspired by the flexible query API of the Django ORM, requests are filtered and matched against routes and their request patterns and lookups . Request patterns are bits of the request, like host method path etc, with given lookup values, combined using bitwise operators to form a Route , i.e. respx.route(path__regex=...) A captured request, matching a Route , resolves to a mocked httpx.Response , or triggers a given side effect . To skip mocking a specific request, a route can be marked to pass through .","title":"User Guide"},{"location":"guide/#mock-httpx","text":"To patch HTTPX , and activate the router, use the respx.mock decorator or context manager.","title":"Mock HTTPX"},{"location":"guide/#using-the-decorator","text":"import httpx import respx @respx . mock def test_decorator (): my_route = respx . get ( \"https://example.org/\" ) response = httpx . get ( \"https://example.org/\" ) assert my_route . called assert response . status_code == 200","title":"Using the Decorator"},{"location":"guide/#using-the-context-manager","text":"import httpx import respx def test_ctx_manager (): with respx . mock : my_route = respx . get ( \"https://example.org/\" ) response = httpx . get ( \"https://example.org/\" ) assert my_route . called assert response . status_code == 200","title":"Using the Context Manager"},{"location":"guide/#router-settings","text":"The RESPX router can be configured with built-in assertion checks and an optional base URL . By configuring, a nested router is created, and the settings are locally bound to the routes added. When decorating a test case with a configured router, the test function will receive the router instance as a respx_mock argument. @respx . mock ( assert_all_mocked = False ) def test_something ( respx_mock ): ... See router configuration reference for more details. Settings Examples: @respx . mock ( assert_all_called = False ) def test_something ( respx_mock ): respx_mock . get ( \"https://example.org/\" ) respx_mock . get ( \"https://some.url/\" ) # Not called, yet not asserted response = httpx . get ( \"https://example.org/\" ) assert response . status_code == 200 with respx . mock ( assert_all_mocked = False ) as respx_mock : response = httpx . get ( \"https://example.org/\" ) # Not mocked, yet not asserted assert response . status_code == 200","title":"Router Settings"},{"location":"guide/#base-url","text":"When adding a lot of routes, sharing the same domain/prefix, you can configure the router with a base_url to be used for added routes. import httpx import respx from httpx import Response @respx . mock ( base_url = \"https://example.org/api/\" ) async def test_something ( respx_mock ): async with httpx . AsyncClient ( base_url = \"https://example.org/api/\" ) as client : respx_mock . get ( \"/baz/\" ) . mock ( return_value = Response ( 200 , text = \"Baz\" )) response = await client . get ( \"/baz/\" ) assert response . text == \"Baz\"","title":"Base URL"},{"location":"guide/#routing-requests","text":"The easiest way to add routes is to use the HTTP Method helpers. For full control over the request pattern matching, use the route API.","title":"Routing Requests"},{"location":"guide/#http-method-helpers","text":"Each HTTP method has a helper function ( get , options , head , post , put , patch , delete ), shortcutting the route API. my_route = respx . get ( \"https://example.org/\" , params = { \"foo\" : \"bar\" }) response = httpx . get ( \"https://example.org/\" , params = { \"foo\" : \"bar\" }) assert my_route . called assert response . status_code == 200 See .get(), .post(), ... helpers reference for more details.","title":"HTTP Method Helpers"},{"location":"guide/#route-api","text":"","title":"Route API"},{"location":"guide/#patterns","text":"With the route API, you define a combined pattern to match, capturing a sent request. my_route = respx . route ( method = \"GET\" , host = \"example.org\" , path = \"/foobar/\" ) response = httpx . get ( \"https://example.org/foobar/\" ) assert my_route . called assert response . status_code == 200 See .route() reference for more details.","title":"Patterns"},{"location":"guide/#lookups","text":"Each pattern has a default lookup. To specify what lookup to use, add a __<lookup> suffix. respx . route ( method__in = [ \"PUT\" , \"PATCH\" ])","title":"Lookups"},{"location":"guide/#combining-patterns","text":"For even more flexability, you can define combined patterns using the M() object , together with bitwise operators ( & , |, ~ ), creating a reusable pattern. hosts_pattern = M ( host = \"example.org\" ) | M ( host = \"example.com\" ) my_route = respx . route ( hosts_pattern , method = \"GET\" , path = \"/foo/\" ) response = httpx . get ( \"http://example.org/foo/\" ) assert response . status_code == 200 assert my_route . called response = httpx . get ( \"https://example.com/foo/\" ) assert response . status_code == 200 assert my_route . call_count == 2 NOTE M(url=\"//example.org/foobar/\") is equal to M(host=\"example.org\") & M(path=\"/foobar/\")","title":"Combining Patterns"},{"location":"guide/#named-routes","text":"Routes can be named when added, and later accessed through the respx.routes mapping. This is useful when a route is added outside the test case, e.g. access or assert route calls. import httpx import respx # Added somewhere else respx . get ( \"https://example.org/\" , name = \"home\" ) @respx . mock def test_route_call (): httpx . get ( \"https://example.org/\" ) assert respx . routes [ \"home\" ] . called assert respx . routes [ \"home\" ] . call_count == 1 last_home_response = respx . routes [ \"home\" ] . calls . last . response assert last_home_response . status_code == 200","title":"Named Routes"},{"location":"guide/#nested-routers","text":"As described under settings , a nested router is created when calling respx.mock(...) . Nested routers are useful when mocking multiple remote APIs, allowing grouped routes per API, and to be mocked individually and reused across tests. Use the nested router as decorator or context manager to patch HTTPX and activate the routes. import httpx import respx from httpx import Response api_mock = respx . mock ( assert_all_called = False ) api_mock . route ( url = \"https://api.foo.bar/baz/\" , name = \"baz\" , ) . mock ( return_value = Response ( 200 , json = { \"name\" : \"baz\" }), ) ... @api_mock def test_decorator (): response = httpx . get ( \"https://api.foo.bar/baz/\" ) assert response . status_code == 200 assert response . json () == { \"name\" : \"baz\" } assert api_mock [ \"baz\" ] . called def test_ctx_manager (): with api_mock : ... NOTE Named routes in a nested router can be directly accessed via my_mock_router[<route name>]","title":"Nested Routers"},{"location":"guide/#mocking-responses","text":"To mock a route response, use <route>.mock(...) to either... set the httpx.Response to be returned . set a side effect to be triggered.","title":"Mocking Responses"},{"location":"guide/#mock-a-response","text":"Create a mocked HTTPX Response object and pass it as return_value . respx . get ( \"https://example.org/\" ) . mock ( return_value = Response ( 204 )) See .mock() reference for more details. You can also use the <route>.return_value setter . route = respx . get ( \"https://example.org/\" ) route . return_value = Response ( 200 , json = { \"foo\" : \"bar\" })","title":"Mock a Response"},{"location":"guide/#mock-with-a-side-effect","text":"RESPX side effects works just like the python Mock side effects. It can either be a function to call, an exception to raise, or an iterable of responses/exceptions to respond with in order, for repeated requests. respx . get ( \"https://example.org/\" ) . mock ( side_effect =... ) You can also use the <route>.side_effect setter . route = respx . get ( \"https://example.org/\" ) route . side_effect = ...","title":"Mock with a Side Effect"},{"location":"guide/#functions","text":"Function side effects will be called with the captured request argument, and should either... return a mocked Response . raise an Exception to simulate a request error. return None to treat the route as a non-match , continuing testing further routes. return the input Request to pass through . import httpx import respx def my_side_effect ( request ): return httpx . Response ( 201 ) @respx . mock def test_side_effect (): respx . post ( \"https://example.org/\" ) . mock ( side_effect = my_side_effect ) response = httpx . post ( \"https://example.org/\" ) assert response . status_code == 201 If any of the route patterns are using a regex lookup , containing named groups , the regex groups will be passed as kwargs to the side effect . import httpx import respx def my_side_effect ( request , slug ): return httpx . Response ( 200 , json = { \"slug\" : slug }) @respx . mock def test_side_effect_kwargs (): route = respx . route ( url__regex = r \"https://example.org/(?P<slug>\\w+)/\" ) route . side_effect = my_side_effect response = httpx . get ( \"https://example.org/foobar/\" ) assert response . status_code == 200 assert response . json () == { \"slug\" : \"foobar\" } A route can even decorate the function to be used as side effect . import httpx import rexpx @respx . route ( url__regex = r \"https://example.org/(?P<user>\\w+)/\" , name = \"user\" ) def user_api ( request , user ): return httpx . Response ( 200 , json = { \"user\" : user }) @respx . mock def test_user_api (): response = httpx . get ( \"https://example.org/lundberg/\" ) assert response . status_code == 200 assert response . json () == { \"user\" : \"lundberg\" } assert respx . routes [ \"user\" ] . called","title":"Functions"},{"location":"guide/#exceptions","text":"To simulate a request error, pass a httpx.HTTPError subclass , or any Exception as side effect . import httpx import respx @respx . mock def test_connection_error (): respx . get ( \"https://example.org/\" ) . mock ( side_effect = httpx . ConnectError ) with pytest . raises ( httpx . ConnectError ): httpx . get ( \"https://example.org/\" )","title":"Exceptions"},{"location":"guide/#iterable","text":"If the side effect is an iterable , each repeated request will get the next Response returned, or exception raised, from the iterable. import httpx import respx @respx . mock def test_stacked_responses (): route = respx . get ( \"https://example.org/\" ) route . side_effect = [ httpx . Response ( 404 ), httpx . Response ( 200 ), ] response1 = httpx . get ( \"https://example.org/\" ) response2 = httpx . get ( \"https://example.org/\" ) assert response1 . status_code == 404 assert response2 . status_code == 200 assert route . call_count == 2","title":"Iterable"},{"location":"guide/#modulo-shortcut","text":"For simple mocking, a quick way is to use the python modulo ( % ) operator to mock the response. The right-hand modulo argument can either be ... An int representing the status_code to mock: respx . get ( \"https://example.org/\" ) % 204 response = httpx . get ( \"https://example.org/\" ) assert response . status_code == 204 A dict used as kwargs to create a mocked HTTPX Response , with status code 200 by default: respx . get ( \"https://example.org/\" ) % dict ( json = { \"foo\" : \"bar\" }) response = httpx . get ( \"https://example.org/\" ) assert response . status_code == 200 assert response . json () == { \"foo\" : \"bar\" } A HTTPX Response object: respx . get ( \"https://example.org/\" ) % Response ( 418 ) response = httpx . get ( \"https://example.org/\" ) assert response . status_code == httpx . codes . IM_A_TEAPOT","title":"Modulo Shortcut"},{"location":"guide/#rollback","text":"When exiting a decorated test case, or context manager , the routes and their mocked values, i.e. return_value and side_effect , will be rolled back and restored to their initial state. This means that you can safely modify existing routes, or add new ones, within a test case, without affecting other tests. import httpx import respx # Initial routes mock_router = respx . mock ( base_url = \"https://example.org\" ) mock_router . get ( path__regex = \"/user/(?P<pk>\\d+)/\" , name = \"user\" ) % 404 ... @mock_router def test_user_exists (): # This change will be rolled back after this test case mock_router [ \"user\" ] . return_value = httpx . Response ( 200 ) response = httpx . get ( \"https://example.org/user/123/\" ) assert response . status_code == 200 @mock_router def test_user_not_found (): response = httpx . get ( \"https://example.org/user/123/\" ) assert response . status_code == 404","title":"Rollback"},{"location":"guide/#pass-through","text":"If you want a route to not capture and mock a request response, use .pass_through() . import httpx import respx @respx . mock def test_remote_response (): respx . route ( host = \"localhost\" ) . pass_through () response = httpx . get ( \"http://localhost:8000/\" ) # respose from server See .pass_through() reference for more details.","title":"Pass Through"},{"location":"guide/#mock-without-patching-httpx","text":"The RESPX implements the HTTP Core transport interface. If you don't need to patch HTTPX , pass a MockTransport as transport , when instantiating your HTTPX client, or alike. import httpx import respx from respx.transports import MockTransport router = respx . Router () router . post ( \"https://example.org/\" ) % 404 def test_client (): mock_transport = MockTransport ( router = router ) with httpx . Client ( transport = mock_transport ) as client : response = client . post ( \"https://example.org/\" ) assert response . status_code == 404 Hint You can use RESPX not only to mock out HTTPX , but actually mock any library using HTTP Core transports.","title":"Mock without patching HTTPX"},{"location":"guide/#call-history","text":"The respx API includes a .calls object, containing captured ( request , response ) named tuples and MagicMock's bells and whistles , i.e. call_count , assert_called etc.","title":"Call History"},{"location":"guide/#asserting-calls","text":"assert respx . calls . called assert respx . calls . call_count == 1 respx . calls . assert_called () respx . calls . assert_not_called () respx . calls . assert_called_once ()","title":"Asserting calls"},{"location":"guide/#retreiving-mocked-calls","text":"A matched and mocked Call can be retrived from call history, by either unpacking... request , response = respx . calls . last request , response = respx . calls [ - 2 ] # by call order ...or by accessing request or response directly... last_request = respx . calls . last . request assert respx . calls . last . response . status_code == 200","title":"Retreiving mocked calls"},{"location":"guide/#local-route-calls","text":"Each Route object has its own .calls , along with .called and .call_count shortcuts. import httpx import respx @respx . mock def test_route_call_stats (): route = respx . post ( \"https://example.org/baz/\" ) % 201 httpx . post ( \"https://example.org/baz/\" ) assert route . calls . last . request . url . path == \"/baz/\" assert route . calls . last . response . status_code == 201 assert route . called assert route . call_count == 1 route . calls . assert_called_once ()","title":"Local route calls"},{"location":"guide/#reset-history","text":"The call history will automatically reset when exiting mocked context, i.e. leaving a decorated test case, or context manager scope. To manually reset call stats during a test case, use respx.reset() or <your_router>.reset() . import httpx import respx @respx . mock def test_reset (): respx . post ( \"https://foo.bar/baz/\" ) httpx . post ( \"https://foo.bar/baz/\" ) assert respx . calls . call_count == 1 respx . calls . assert_called_once () respx . reset () assert len ( respx . calls ) == 0 assert respx . calls . call_count == 0 respx . calls . assert_not_called ()","title":"Reset History"},{"location":"mocking/","text":"Mock HTTPX RESPX is a mock router, capturing requests sent by HTTPX , mocking their responses. Inspired by the flexible query API of the Django ORM, requests are filtered and matched against routes and their request patterns and lookups . Request patterns are bits of the request, like host method path etc, with given lookup values, combined using bitwise operators to form a Route , i.e. respx.route(path__regex=...) A captured request, matching a Route , resolves to a mocked httpx.Response , or triggers a given side effect . To skip mocking a specific request, a route can be marked to pass through . Read the User Guide for a complete walk-through.","title":"Mock HTTPX"},{"location":"mocking/#mock-httpx","text":"RESPX is a mock router, capturing requests sent by HTTPX , mocking their responses. Inspired by the flexible query API of the Django ORM, requests are filtered and matched against routes and their request patterns and lookups . Request patterns are bits of the request, like host method path etc, with given lookup values, combined using bitwise operators to form a Route , i.e. respx.route(path__regex=...) A captured request, matching a Route , resolves to a mocked httpx.Response , or triggers a given side effect . To skip mocking a specific request, a route can be marked to pass through . Read the User Guide for a complete walk-through.","title":"Mock HTTPX"},{"location":"upgrade/","text":"Upgrade Guide As of RESPX version 0.15.0 , the API has changed, but kept with deprecation warnings, later to be broken for backward compatibility in 0.16.0 . The biggest change involved separating request pattern arguments from response details. This brings the RESPX request matching API closer to the HTTPX client API, and the response mocking aligned with the python Mock API. Responses Response details are now mocked separatelty: # Previously respx . post ( \"https://some.url/\" , status_code = 200 , content = { \"x\" : 1 }) # Now respx . post ( \"https://some.url/\" ) . mock ( return_value = Response ( 200 , json = { \"x\" : 1 })) respx . post ( \"https://some.url/\" ) . respond ( 200 , json = { \"x\" : 1 }) respx . post ( \"https://some.url/\" ) % dict ( json = { \"x\" : 1 }) The .add API has changed to .route : # Previously respx . add ( \"POST\" , \"https://some.url/\" , content = \"foobar\" ) # Now respx . route ( method = \"POST\" , url = \"https://some.url/\" ) . respond ( content = \"foobar\" ) Callbacks Callbacks and simulated errors are now side effects : # Previously respx . post ( \"https://some.url/\" , content = callback ) respx . post ( \"https://some.url/\" , content = Exception ()) respx . add ( callback ) # Now respx . post ( \"https://some.url/\" ) . mock ( side_effect = callback ) respx . post ( \"https://some.url/\" ) . mock ( side_effect = Exception ) respx . route () . mock ( side_effect = callback ) Stacking Repeating a mocked response, for stacking, is now solved with side effects : # Previously respx . post ( \"https://some.url/\" , status_code = 404 ) respx . post ( \"https://some.url/\" , status_code = 200 ) # Now respx . post ( \"https://some.url/\" ) . mock ( side_effect = [ Response ( 404 ), Response ( 200 ), ], ) Note: Repeating a route in 0.15.0+ replaces any exising route with same pattern. Aliasing Aliases changed to named routes : # Previously respx . post ( \"https://example.org/\" , alias = \"example\" ) assert respx . aliases [ \"example\" ] . called # Now respx . post ( \"https://example.org/\" , name = \"example\" ) assert respx . routes [ \"example\" ] . called History Call history renamed : # Previously assert respx . stats . call_count == 1 # Now assert respx . calls . call_count == 1 MockTransport The respx.MockTransport should no longer be used as a mock router, use respx.mock(...) . # Previously my_mock = respx . MockTransport ( assert_all_called = False ) # Now my_mock = respx . mock ( assert_all_called = False )","title":"Upgrading"},{"location":"upgrade/#upgrade-guide","text":"As of RESPX version 0.15.0 , the API has changed, but kept with deprecation warnings, later to be broken for backward compatibility in 0.16.0 . The biggest change involved separating request pattern arguments from response details. This brings the RESPX request matching API closer to the HTTPX client API, and the response mocking aligned with the python Mock API.","title":"Upgrade Guide"},{"location":"upgrade/#responses","text":"Response details are now mocked separatelty: # Previously respx . post ( \"https://some.url/\" , status_code = 200 , content = { \"x\" : 1 }) # Now respx . post ( \"https://some.url/\" ) . mock ( return_value = Response ( 200 , json = { \"x\" : 1 })) respx . post ( \"https://some.url/\" ) . respond ( 200 , json = { \"x\" : 1 }) respx . post ( \"https://some.url/\" ) % dict ( json = { \"x\" : 1 }) The .add API has changed to .route : # Previously respx . add ( \"POST\" , \"https://some.url/\" , content = \"foobar\" ) # Now respx . route ( method = \"POST\" , url = \"https://some.url/\" ) . respond ( content = \"foobar\" )","title":"Responses"},{"location":"upgrade/#callbacks","text":"Callbacks and simulated errors are now side effects : # Previously respx . post ( \"https://some.url/\" , content = callback ) respx . post ( \"https://some.url/\" , content = Exception ()) respx . add ( callback ) # Now respx . post ( \"https://some.url/\" ) . mock ( side_effect = callback ) respx . post ( \"https://some.url/\" ) . mock ( side_effect = Exception ) respx . route () . mock ( side_effect = callback )","title":"Callbacks"},{"location":"upgrade/#stacking","text":"Repeating a mocked response, for stacking, is now solved with side effects : # Previously respx . post ( \"https://some.url/\" , status_code = 404 ) respx . post ( \"https://some.url/\" , status_code = 200 ) # Now respx . post ( \"https://some.url/\" ) . mock ( side_effect = [ Response ( 404 ), Response ( 200 ), ], ) Note: Repeating a route in 0.15.0+ replaces any exising route with same pattern.","title":"Stacking"},{"location":"upgrade/#aliasing","text":"Aliases changed to named routes : # Previously respx . post ( \"https://example.org/\" , alias = \"example\" ) assert respx . aliases [ \"example\" ] . called # Now respx . post ( \"https://example.org/\" , name = \"example\" ) assert respx . routes [ \"example\" ] . called","title":"Aliasing"},{"location":"upgrade/#history","text":"Call history renamed : # Previously assert respx . stats . call_count == 1 # Now assert respx . calls . call_count == 1","title":"History"},{"location":"upgrade/#mocktransport","text":"The respx.MockTransport should no longer be used as a mock router, use respx.mock(...) . # Previously my_mock = respx . MockTransport ( assert_all_called = False ) # Now my_mock = respx . mock ( assert_all_called = False )","title":"MockTransport"},{"location":"versions/0.14.0/api/","text":"Warning This is the documentaion of the older version 0.14.0 . See latest for current release. Developer Interface - Version 0.14.0 Mocking Responses HTTP Method API For regular and simple use, use the HTTP method shorthands. See Request API for parameters. respx. get ( url=None , * , name=None , **lookups ) respx. options (...) respx. head (...) respx. post (...) respx. put (...) respx. patch (...) respx. delete (...) Request API For full control, use the core add method. respx. add ( route , * , name=None ) Parameters: method - str | callable | RequestPattern Request HTTP method, or Request callback , to match. url - (optional) str | pattern | tuple (httpcore) | httpx.URL Request exact URL, or URL pattern , to match. params - (optional) str | list | dict Request URL params to merge with url. status_code - (optional) int - default: 200 Response status code to mock. headers - (optional) dict Response headers to mock. content_type - (optional) str Response Content-Type header value to mock. content - (optional) bytes | str | list | dict | callable | exception - default b\"\" Response content to mock. - See Response Content . text - (optional) str Response text content to mock, with automatic content type header. html - (optional) str Response html content to mock, with automatic content type header. json - (optional) str | list | dict Response json content to mock, with automatic content type header. pass_through - (optional) bool - default False Mark matched request to pass-through to real server, e.g. don't mock . alias - (optional) str Name this request pattern. - See Call Statistics . Matching Requests Exact URL To match and mock a request by an exact URL, pass the url parameter as a string . respx . get ( \"https://foo.bar/\" , status_code = 204 ) URL pattern Instead of matching an exact URL , you can pass a compiled regex to match the request URL. import httpx import re import respx @respx . mock def test_something (): url_pattern = re . compile ( r \"^https://foo.bar/\\w+/$\" ) respx . get ( url_pattern , content = \"Baz\" ) response = httpx . get ( \"https://foo.bar/baz/\" ) assert response . text == \"Baz\" Tip Named groups in the regex pattern will be passed as kwargs to the response content callback , if used. Base URL When adding a lot of request patterns sharing the same domain/prefix, you can configure RESPX with a base_url to use as the base when matching URLs. Like url , the base_url can also be passed as a compiled regex , with optional named groups. import httpx import respx @respx . mock ( base_url = \"https://foo.bar\" ) async def test_something ( respx_mock ): async with httpx . AsyncClient ( base_url = \"https://foo.bar\" ) as client : request = respx_mock . get ( \"/baz/\" , content = \"Baz\" ) response = await client . get ( \"/baz/\" ) assert response . text == \"Baz\" Request callback For full control of what request to match and what response to mock , pass a callback function as the add(method, ...) parameter. The callback's response argument will be pre-populated with any additional response parameters. import httpx import respx def match_and_mock ( request , response ): \"\"\" Return `None` to not match the request. Return the `response` to match and mock this request. Return the `request` for pass-through behaviour. \"\"\" if request . method != \"POST\" : return None if \"X-Auth-Token\" not in request . headers : response . status_code = 401 else : response . content = \"OK\" return response @respx . mock def test_something (): custom_request = respx . add ( match_and_mock , status_code = 201 ) respx . get ( \"https://foo.bar/baz/\" ) response = httpx . get ( \"https://foo.bar/baz/\" ) assert response . status_code == 200 assert not custom_request . called response = httpx . post ( \"https://foo.bar/baz/\" ) assert response . status_code == 401 assert custom_request . called response = httpx . post ( \"https://foo.bar/baz/\" , headers = { \"X-Auth-Token\" : \"x\" }) assert response . status_code == 201 assert custom_request . call_count == 2 Repeated patterns If you mock several responses with the same request pattern , they will be matched in order, and popped til the last one. import httpx import respx @respx . mock def test_something (): respx . get ( \"https://foo.bar/baz/123/\" , status_code = 404 ) respx . get ( \"https://foo.bar/baz/123/\" , content = { \"id\" : 123 }) respx . post ( \"https://foo.bar/baz/\" , status_code = 201 ) response = httpx . get ( \"https://foo.bar/baz/123/\" ) assert response . status_code == 404 # First match response = httpx . post ( \"https://foo.bar/baz/\" ) assert response . status_code == 201 response = httpx . get ( \"https://foo.bar/baz/123/\" ) assert response . status_code == 200 # Second match assert response . json () == { \"id\" : 123 } Manipulating Existing Patterns Clearing all existing patterns: import respx @respx . mock def test_something (): respx . get ( \"https://foo.bar/baz\" , status_code = 404 ) respx . clear () # no patterns will be matched after this call Removing and optionally re-using an existing pattern by alias: import respx @respx . mock def test_something (): respx . get ( \"https://foo.bar/\" , status_code = 404 , alias = \"index\" ) request_pattern = respx . pop ( \"index\" ) respx . get ( request_pattern . url , status_code = 200 ) Response Content JSON content To mock a response with json content, pass a list or a dict . The Content-Type header will automatically be set to application/json . import httpx import respx @respx . mock def test_something (): respx . get ( \"https://foo.bar/baz/123/\" , content = { \"id\" : 123 }) response = httpx . get ( \"https://foo.bar/baz/123/\" ) assert response . json () == { \"id\" : 123 } Content callback If you need dynamic response content, pass a callback function. When used together with a URL pattern , named groups will be passed as kwargs . import httpx import re import respx def some_content ( request , slug = None ): \"\"\" Return bytes, str, list or a dict. \"\"\" return { \"slug\" : slug } @respx . mock def test_something (): url_pattern = r \"^https://foo.bar/(?P<slug>\\w+)/$\" ) respx . get ( url_pattern , content = some_content ) response = httpx . get ( \"https://foo.bar/apa/\" ) assert response . json () == { \"slug\" : \"apa\" } Request Error To simulate a failing request, like a connection error , pass an Exception instance. This is useful when you need to test proper HTTPX error handling in your app. import httpx import httpcore import respx @respx . mock def test_something (): respx . get ( \"https://foo.bar/\" , content = httpcore . ConnectTimeout ()) response = httpx . get ( \"https://foo.bar/\" ) # Will raise Built-in Assertions RESPX has the following build-in assertion checks: assert_all_mocked Asserts that all captured HTTPX requests are mocked. Defaults to True . assert_all_called Asserts that all mocked request patterns were called. Defaults to True . Configure checks by using the respx.mock decorator / context manager with parentheses. @respx . mock ( assert_all_called = False ) def test_something ( respx_mock ): respx_mock . get ( \"https://some.url/\" ) # OK respx_mock . get ( \"https://foo.bar/\" ) response = httpx . get ( \"https://foo.bar/\" ) assert response . status_code == 200 assert respx_mock . calls . call_count == 1 with respx . mock ( assert_all_mocked = False ) as respx_mock : response = httpx . get ( \"https://foo.bar/\" ) # OK assert response . status_code == 200 assert respx_mock . calls . call_count == 1 Without Parentheses When using the global scope @respx.mock decorator / context manager, assert_all_called is disabled . Call History The respx API includes a .calls object, containing captured ( request , response ) named tuples and MagicMock's bells and whistles , i.e. call_count , assert_called etc. Retreiving mocked calls A matched and mocked Call can be retrived from call history, by either unpacking... request , response = respx . calls . last request , response = respx . calls [ - 2 ] # by call order ...or by accessing request or response directly... last_response = respx . calls . last . response assert respx . calls . last . request . call_count == 1 assert respx . calls . last . response . status_code == 200 Deprecation Warning As of version 0.14.0 , statistics via respx.stats is deprecated, in favour of respx.calls . Request Pattern calls Each mocked response request pattern has its own .calls , along with .called and .call_count stats shortcuts. Example using locally added request pattern: import httpx import respx @respx . mock def test_something (): request = respx . post ( \"https://foo.bar/baz/\" , status_code = 201 ) httpx . post ( \"https://foo.bar/baz/\" ) assert request . called assert request . call_count == 1 assert request . calls . last . response . status_code == 201 request . calls . assert_called_once () Example using globally aliased request pattern: import httpx import respx # Added somewhere outside the test respx . get ( \"https://foo.bar/\" , alias = \"index\" ) @respx . mock def test_something (): httpx . get ( \"https://foo.bar/\" ) assert respx . aliases [ \"index\" ] . called assert respx . aliases [ \"index\" ] . call_count == 1 last_index_response = respx . aliases [ \"index\" ] . calls . last . response Reset stats To reset stats during a test case, without stop mocking , use respx.reset() . import httpx import respx @respx . mock def test_something (): respx . post ( \"https://foo.bar/baz/\" ) httpx . post ( \"https://foo.bar/baz/\" ) assert respx . calls . call_count == 1 request . calls . assert_called_once () respx . reset () assert len ( respx . calls ) == 0 assert respx . calls . call_count == 0 respx . calls . assert_not_called () Examples Here's a handful example usages of the call stats API. import httpx import respx @respx . mock def test_something (): # Mock some calls respx . get ( \"https://foo.bar/\" , alias = \"index\" ) baz_request = respx . post ( \"https://foo.bar/baz/\" , status_code = 201 ) # Make some calls httpx . get ( \"https://foo.bar/\" ) httpx . post ( \"https://foo.bar/baz/\" ) # Assert mocked assert respx . aliases [ \"index\" ] . called assert respx . aliases [ \"index\" ] . call_count == 1 assert baz_request . called assert baz_request . call_count == 1 baz_request . calls . assert_called_once () # Global stats increased assert respx . calls . call_count == 2 # Assert responses assert respx . aliases [ \"index\" ] . calls . last . response . status_code == 200 assert respx . calls . last . response is baz_request . calls . last . response assert respx . calls . last . response . status_code == 201 # Reset respx . reset () assert len ( respx . calls ) == 0 assert respx . calls . call_count == 0 respx . calls . assert_not_called ()","title":"Developer Interface"},{"location":"versions/0.14.0/api/#developer-interface-version-0140","text":"","title":"Developer Interface - Version 0.14.0"},{"location":"versions/0.14.0/api/#mocking-responses","text":"","title":"Mocking Responses"},{"location":"versions/0.14.0/api/#http-method-api","text":"For regular and simple use, use the HTTP method shorthands. See Request API for parameters. respx. get ( url=None , * , name=None , **lookups ) respx. options (...) respx. head (...) respx. post (...) respx. put (...) respx. patch (...) respx. delete (...)","title":"HTTP Method API"},{"location":"versions/0.14.0/api/#request-api","text":"For full control, use the core add method. respx. add ( route , * , name=None ) Parameters: method - str | callable | RequestPattern Request HTTP method, or Request callback , to match. url - (optional) str | pattern | tuple (httpcore) | httpx.URL Request exact URL, or URL pattern , to match. params - (optional) str | list | dict Request URL params to merge with url. status_code - (optional) int - default: 200 Response status code to mock. headers - (optional) dict Response headers to mock. content_type - (optional) str Response Content-Type header value to mock. content - (optional) bytes | str | list | dict | callable | exception - default b\"\" Response content to mock. - See Response Content . text - (optional) str Response text content to mock, with automatic content type header. html - (optional) str Response html content to mock, with automatic content type header. json - (optional) str | list | dict Response json content to mock, with automatic content type header. pass_through - (optional) bool - default False Mark matched request to pass-through to real server, e.g. don't mock . alias - (optional) str Name this request pattern. - See Call Statistics .","title":"Request API"},{"location":"versions/0.14.0/api/#matching-requests","text":"","title":"Matching Requests"},{"location":"versions/0.14.0/api/#exact-url","text":"To match and mock a request by an exact URL, pass the url parameter as a string . respx . get ( \"https://foo.bar/\" , status_code = 204 )","title":"Exact URL"},{"location":"versions/0.14.0/api/#url-pattern","text":"Instead of matching an exact URL , you can pass a compiled regex to match the request URL. import httpx import re import respx @respx . mock def test_something (): url_pattern = re . compile ( r \"^https://foo.bar/\\w+/$\" ) respx . get ( url_pattern , content = \"Baz\" ) response = httpx . get ( \"https://foo.bar/baz/\" ) assert response . text == \"Baz\" Tip Named groups in the regex pattern will be passed as kwargs to the response content callback , if used.","title":"URL pattern"},{"location":"versions/0.14.0/api/#base-url","text":"When adding a lot of request patterns sharing the same domain/prefix, you can configure RESPX with a base_url to use as the base when matching URLs. Like url , the base_url can also be passed as a compiled regex , with optional named groups. import httpx import respx @respx . mock ( base_url = \"https://foo.bar\" ) async def test_something ( respx_mock ): async with httpx . AsyncClient ( base_url = \"https://foo.bar\" ) as client : request = respx_mock . get ( \"/baz/\" , content = \"Baz\" ) response = await client . get ( \"/baz/\" ) assert response . text == \"Baz\"","title":"Base URL"},{"location":"versions/0.14.0/api/#request-callback","text":"For full control of what request to match and what response to mock , pass a callback function as the add(method, ...) parameter. The callback's response argument will be pre-populated with any additional response parameters. import httpx import respx def match_and_mock ( request , response ): \"\"\" Return `None` to not match the request. Return the `response` to match and mock this request. Return the `request` for pass-through behaviour. \"\"\" if request . method != \"POST\" : return None if \"X-Auth-Token\" not in request . headers : response . status_code = 401 else : response . content = \"OK\" return response @respx . mock def test_something (): custom_request = respx . add ( match_and_mock , status_code = 201 ) respx . get ( \"https://foo.bar/baz/\" ) response = httpx . get ( \"https://foo.bar/baz/\" ) assert response . status_code == 200 assert not custom_request . called response = httpx . post ( \"https://foo.bar/baz/\" ) assert response . status_code == 401 assert custom_request . called response = httpx . post ( \"https://foo.bar/baz/\" , headers = { \"X-Auth-Token\" : \"x\" }) assert response . status_code == 201 assert custom_request . call_count == 2","title":"Request callback"},{"location":"versions/0.14.0/api/#repeated-patterns","text":"If you mock several responses with the same request pattern , they will be matched in order, and popped til the last one. import httpx import respx @respx . mock def test_something (): respx . get ( \"https://foo.bar/baz/123/\" , status_code = 404 ) respx . get ( \"https://foo.bar/baz/123/\" , content = { \"id\" : 123 }) respx . post ( \"https://foo.bar/baz/\" , status_code = 201 ) response = httpx . get ( \"https://foo.bar/baz/123/\" ) assert response . status_code == 404 # First match response = httpx . post ( \"https://foo.bar/baz/\" ) assert response . status_code == 201 response = httpx . get ( \"https://foo.bar/baz/123/\" ) assert response . status_code == 200 # Second match assert response . json () == { \"id\" : 123 }","title":"Repeated patterns"},{"location":"versions/0.14.0/api/#manipulating-existing-patterns","text":"Clearing all existing patterns: import respx @respx . mock def test_something (): respx . get ( \"https://foo.bar/baz\" , status_code = 404 ) respx . clear () # no patterns will be matched after this call Removing and optionally re-using an existing pattern by alias: import respx @respx . mock def test_something (): respx . get ( \"https://foo.bar/\" , status_code = 404 , alias = \"index\" ) request_pattern = respx . pop ( \"index\" ) respx . get ( request_pattern . url , status_code = 200 )","title":"Manipulating Existing Patterns"},{"location":"versions/0.14.0/api/#response-content","text":"","title":"Response Content"},{"location":"versions/0.14.0/api/#json-content","text":"To mock a response with json content, pass a list or a dict . The Content-Type header will automatically be set to application/json . import httpx import respx @respx . mock def test_something (): respx . get ( \"https://foo.bar/baz/123/\" , content = { \"id\" : 123 }) response = httpx . get ( \"https://foo.bar/baz/123/\" ) assert response . json () == { \"id\" : 123 }","title":"JSON content"},{"location":"versions/0.14.0/api/#content-callback","text":"If you need dynamic response content, pass a callback function. When used together with a URL pattern , named groups will be passed as kwargs . import httpx import re import respx def some_content ( request , slug = None ): \"\"\" Return bytes, str, list or a dict. \"\"\" return { \"slug\" : slug } @respx . mock def test_something (): url_pattern = r \"^https://foo.bar/(?P<slug>\\w+)/$\" ) respx . get ( url_pattern , content = some_content ) response = httpx . get ( \"https://foo.bar/apa/\" ) assert response . json () == { \"slug\" : \"apa\" }","title":"Content callback"},{"location":"versions/0.14.0/api/#request-error","text":"To simulate a failing request, like a connection error , pass an Exception instance. This is useful when you need to test proper HTTPX error handling in your app. import httpx import httpcore import respx @respx . mock def test_something (): respx . get ( \"https://foo.bar/\" , content = httpcore . ConnectTimeout ()) response = httpx . get ( \"https://foo.bar/\" ) # Will raise","title":"Request Error"},{"location":"versions/0.14.0/api/#built-in-assertions","text":"RESPX has the following build-in assertion checks: assert_all_mocked Asserts that all captured HTTPX requests are mocked. Defaults to True . assert_all_called Asserts that all mocked request patterns were called. Defaults to True . Configure checks by using the respx.mock decorator / context manager with parentheses. @respx . mock ( assert_all_called = False ) def test_something ( respx_mock ): respx_mock . get ( \"https://some.url/\" ) # OK respx_mock . get ( \"https://foo.bar/\" ) response = httpx . get ( \"https://foo.bar/\" ) assert response . status_code == 200 assert respx_mock . calls . call_count == 1 with respx . mock ( assert_all_mocked = False ) as respx_mock : response = httpx . get ( \"https://foo.bar/\" ) # OK assert response . status_code == 200 assert respx_mock . calls . call_count == 1 Without Parentheses When using the global scope @respx.mock decorator / context manager, assert_all_called is disabled .","title":"Built-in Assertions"},{"location":"versions/0.14.0/api/#call-history","text":"The respx API includes a .calls object, containing captured ( request , response ) named tuples and MagicMock's bells and whistles , i.e. call_count , assert_called etc.","title":"Call History"},{"location":"versions/0.14.0/api/#retreiving-mocked-calls","text":"A matched and mocked Call can be retrived from call history, by either unpacking... request , response = respx . calls . last request , response = respx . calls [ - 2 ] # by call order ...or by accessing request or response directly... last_response = respx . calls . last . response assert respx . calls . last . request . call_count == 1 assert respx . calls . last . response . status_code == 200 Deprecation Warning As of version 0.14.0 , statistics via respx.stats is deprecated, in favour of respx.calls .","title":"Retreiving mocked calls"},{"location":"versions/0.14.0/api/#request-pattern-calls","text":"Each mocked response request pattern has its own .calls , along with .called and .call_count stats shortcuts. Example using locally added request pattern: import httpx import respx @respx . mock def test_something (): request = respx . post ( \"https://foo.bar/baz/\" , status_code = 201 ) httpx . post ( \"https://foo.bar/baz/\" ) assert request . called assert request . call_count == 1 assert request . calls . last . response . status_code == 201 request . calls . assert_called_once () Example using globally aliased request pattern: import httpx import respx # Added somewhere outside the test respx . get ( \"https://foo.bar/\" , alias = \"index\" ) @respx . mock def test_something (): httpx . get ( \"https://foo.bar/\" ) assert respx . aliases [ \"index\" ] . called assert respx . aliases [ \"index\" ] . call_count == 1 last_index_response = respx . aliases [ \"index\" ] . calls . last . response","title":"Request Pattern calls"},{"location":"versions/0.14.0/api/#reset-stats","text":"To reset stats during a test case, without stop mocking , use respx.reset() . import httpx import respx @respx . mock def test_something (): respx . post ( \"https://foo.bar/baz/\" ) httpx . post ( \"https://foo.bar/baz/\" ) assert respx . calls . call_count == 1 request . calls . assert_called_once () respx . reset () assert len ( respx . calls ) == 0 assert respx . calls . call_count == 0 respx . calls . assert_not_called ()","title":"Reset stats"},{"location":"versions/0.14.0/api/#examples","text":"Here's a handful example usages of the call stats API. import httpx import respx @respx . mock def test_something (): # Mock some calls respx . get ( \"https://foo.bar/\" , alias = \"index\" ) baz_request = respx . post ( \"https://foo.bar/baz/\" , status_code = 201 ) # Make some calls httpx . get ( \"https://foo.bar/\" ) httpx . post ( \"https://foo.bar/baz/\" ) # Assert mocked assert respx . aliases [ \"index\" ] . called assert respx . aliases [ \"index\" ] . call_count == 1 assert baz_request . called assert baz_request . call_count == 1 baz_request . calls . assert_called_once () # Global stats increased assert respx . calls . call_count == 2 # Assert responses assert respx . aliases [ \"index\" ] . calls . last . response . status_code == 200 assert respx . calls . last . response is baz_request . calls . last . response assert respx . calls . last . response . status_code == 201 # Reset respx . reset () assert len ( respx . calls ) == 0 assert respx . calls . call_count == 0 respx . calls . assert_not_called ()","title":"Examples"},{"location":"versions/0.14.0/mocking/","text":"Warning This is the documentaion of the older version 0.14.0 . See latest for current release. Mock HTTPX - Version 0.14.0 To mock out HTTPX and/or HTTP Core , use the respx.mock decorator / context manager. Optionally configure built-in assertion checks and base URL with respx.mock(...) . Using the Decorator import httpx import respx @respx . mock def test_something (): request = respx . get ( \"https://foo.bar/\" , content = \"foobar\" ) response = httpx . get ( \"https://foo.bar/\" ) assert request . called assert response . status_code == 200 assert response . text == \"foobar\" Using the Context Manager import httpx import respx with respx . mock : request = respx . get ( \"https://foo.bar/\" , content = \"foobar\" ) response = httpx . get ( \"https://foo.bar/\" ) assert request . called assert response . status_code == 200 assert response . text == \"foobar\" NOTE You can also start and stop mocking HTTPX manually, by calling respx.start() and respx.stop() . Using the mock Transports The built-in transports are the base of all mocking and patching in RESPX. In fact , respx.mock is an actual instance of MockTransport . MockTransport import httpx import respx mock_transport = respx . MockTransport () request = mock_transport . get ( \"https://foo.bar/\" , content = \"foobar\" ) with mock_transport : response = httpx . get ( \"https://foo.bar/\" ) assert request . called assert response . status_code == 200 assert response . text == \"foobar\" SyncMockTransport If you don't need to patch the original HTTPX / HTTP Core transports, then use the SyncMockTransport or AsyncMockTransport directly, by passing the transport arg when instantiating your HTTPX client, or alike. import httpx import respx mock_transport = respx . SyncMockTransport () request = mock_transport . get ( \"https://foo.bar/\" , content = \"foobar\" ) with httpx . Client ( transport = mock_transport ) as client : response = client . get ( \"https://foo.bar/\" ) assert request . called assert response . status_code == 200 assert response . text == \"foobar\" AsyncMockTransport import httpx import respx mock_transport = respx . AsyncMockTransport () request = mock_transport . get ( \"https://foo.bar/\" , content = \"foobar\" ) async with httpx . AsyncClient ( transport = mock_transport ) as client : response = await client . get ( \"https://foo.bar/\" ) assert request . called assert response . status_code == 200 assert response . text == \"foobar\" NOTE The mock transports takes the same configuration arguments as the decorator / context manager. Global Setup & Teardown pytest # conftest.py import pytest import respx @pytest . fixture def mocked_api (): with respx . mock ( base_url = \"https://foo.bar\" ) as respx_mock : respx_mock . get ( \"/users/\" , content = [], alias = \"list_users\" ) ... yield respx_mock # test_api.py import httpx def test_list_users ( mocked_api ): response = httpx . get ( \"https://foo.bar/users/\" ) request = mocked_api [ \"list_users\" ] assert request . called assert response . json () == [] Tip Use a session scoped fixture @pytest.fixture(scope=\"session\") when your fixture contains multiple endpoints that not necessary gets called by a single test case, or disable the built-in assert_all_called check. unittest # testcases.py class MockedAPIMixin : def setUp ( self ): self . mocked_api = respx . mock ( base_url = \"https://foo.bar\" ) self . mocked_api . get ( \"/users/\" , content = [], alias = \"list_users\" ) ... self . mocked_api . start () def tearDown ( self ): self . mocked_api . stop () # test_api.py import unittest import httpx from .testcases import MockedAPIMixin class MyTestCase ( MockedAPIMixin , unittest . TestCase ): def test_list_users ( self ): response = httpx . get ( \"https://foo.bar/users/\" ) request = self . mocked_api [ \"list_users\" ] assert request . called assert response . json () == [] Tip Use setUpClass and tearDownClass when you mock multiple endpoints that not necessary gets called by a single test method, or disable the built-in assert_all_called check. Async Support You can use respx.mock in both sync and async contexts to mock out HTTPX responses. pytest @respx . mock @pytest . mark . asyncio async def test_something (): async with httpx . AsyncClient () as client : request = respx . get ( \"https://foo.bar/\" , content = \"foobar\" ) response = await client . get ( \"https://foo.bar/\" ) assert request . called assert response . text == \"foobar\" @pytest . mark . asyncio async def test_something (): async with respx . mock : async with httpx . AsyncClient () as client : request = respx . get ( \"https://foo.bar/\" , content = \"foobar\" ) response = await client . get ( \"https://foo.bar/\" ) assert request . called assert response . text == \"foobar\" Session Scoped Fixtures If a session scoped RESPX fixture is used in an async context, you also need to broaden the pytest-asyncio event_loop fixture. You can use the session_event_loop utility for this. # conftest.py import pytest import respx from respx.fixtures import session_event_loop as event_loop # noqa: F401 @pytest . fixture ( scope = \"session\" ) async def mocked_api ( event_loop ): # noqa: F811 async with respx . mock ( base_url = \"https://foo.bar\" ) as respx_mock : ... yield respx_mock unittest import asynctest class MyTestCase ( asynctest . TestCase ): @respx . mock async def test_something ( self ): async with httpx . AsyncClient () as client : request = respx . get ( \"https://foo.bar/\" , content = \"foobar\" ) response = await client . get ( \"https://foo.bar/\" ) assert request . called assert response . text == \"foobar\" async def test_something ( self ): async with respx . mock : async with httpx . AsyncClient () as client : request = respx . get ( \"https://foo.bar/\" , content = \"foobar\" ) response = await client . get ( \"https://foo.bar/\" ) assert request . called assert response . text == \"foobar\"","title":"Mock HTTPX"},{"location":"versions/0.14.0/mocking/#mock-httpx-version-0140","text":"To mock out HTTPX and/or HTTP Core , use the respx.mock decorator / context manager. Optionally configure built-in assertion checks and base URL with respx.mock(...) .","title":"Mock HTTPX - Version 0.14.0"},{"location":"versions/0.14.0/mocking/#using-the-decorator","text":"import httpx import respx @respx . mock def test_something (): request = respx . get ( \"https://foo.bar/\" , content = \"foobar\" ) response = httpx . get ( \"https://foo.bar/\" ) assert request . called assert response . status_code == 200 assert response . text == \"foobar\"","title":"Using the Decorator"},{"location":"versions/0.14.0/mocking/#using-the-context-manager","text":"import httpx import respx with respx . mock : request = respx . get ( \"https://foo.bar/\" , content = \"foobar\" ) response = httpx . get ( \"https://foo.bar/\" ) assert request . called assert response . status_code == 200 assert response . text == \"foobar\" NOTE You can also start and stop mocking HTTPX manually, by calling respx.start() and respx.stop() .","title":"Using the Context Manager"},{"location":"versions/0.14.0/mocking/#using-the-mock-transports","text":"The built-in transports are the base of all mocking and patching in RESPX. In fact , respx.mock is an actual instance of MockTransport .","title":"Using the mock Transports"},{"location":"versions/0.14.0/mocking/#mocktransport","text":"import httpx import respx mock_transport = respx . MockTransport () request = mock_transport . get ( \"https://foo.bar/\" , content = \"foobar\" ) with mock_transport : response = httpx . get ( \"https://foo.bar/\" ) assert request . called assert response . status_code == 200 assert response . text == \"foobar\"","title":"MockTransport"},{"location":"versions/0.14.0/mocking/#syncmocktransport","text":"If you don't need to patch the original HTTPX / HTTP Core transports, then use the SyncMockTransport or AsyncMockTransport directly, by passing the transport arg when instantiating your HTTPX client, or alike. import httpx import respx mock_transport = respx . SyncMockTransport () request = mock_transport . get ( \"https://foo.bar/\" , content = \"foobar\" ) with httpx . Client ( transport = mock_transport ) as client : response = client . get ( \"https://foo.bar/\" ) assert request . called assert response . status_code == 200 assert response . text == \"foobar\"","title":"SyncMockTransport"},{"location":"versions/0.14.0/mocking/#asyncmocktransport","text":"import httpx import respx mock_transport = respx . AsyncMockTransport () request = mock_transport . get ( \"https://foo.bar/\" , content = \"foobar\" ) async with httpx . AsyncClient ( transport = mock_transport ) as client : response = await client . get ( \"https://foo.bar/\" ) assert request . called assert response . status_code == 200 assert response . text == \"foobar\" NOTE The mock transports takes the same configuration arguments as the decorator / context manager.","title":"AsyncMockTransport"},{"location":"versions/0.14.0/mocking/#global-setup-teardown","text":"","title":"Global Setup &amp; Teardown"},{"location":"versions/0.14.0/mocking/#pytest","text":"# conftest.py import pytest import respx @pytest . fixture def mocked_api (): with respx . mock ( base_url = \"https://foo.bar\" ) as respx_mock : respx_mock . get ( \"/users/\" , content = [], alias = \"list_users\" ) ... yield respx_mock # test_api.py import httpx def test_list_users ( mocked_api ): response = httpx . get ( \"https://foo.bar/users/\" ) request = mocked_api [ \"list_users\" ] assert request . called assert response . json () == [] Tip Use a session scoped fixture @pytest.fixture(scope=\"session\") when your fixture contains multiple endpoints that not necessary gets called by a single test case, or disable the built-in assert_all_called check.","title":"pytest"},{"location":"versions/0.14.0/mocking/#unittest","text":"# testcases.py class MockedAPIMixin : def setUp ( self ): self . mocked_api = respx . mock ( base_url = \"https://foo.bar\" ) self . mocked_api . get ( \"/users/\" , content = [], alias = \"list_users\" ) ... self . mocked_api . start () def tearDown ( self ): self . mocked_api . stop () # test_api.py import unittest import httpx from .testcases import MockedAPIMixin class MyTestCase ( MockedAPIMixin , unittest . TestCase ): def test_list_users ( self ): response = httpx . get ( \"https://foo.bar/users/\" ) request = self . mocked_api [ \"list_users\" ] assert request . called assert response . json () == [] Tip Use setUpClass and tearDownClass when you mock multiple endpoints that not necessary gets called by a single test method, or disable the built-in assert_all_called check.","title":"unittest"},{"location":"versions/0.14.0/mocking/#async-support","text":"You can use respx.mock in both sync and async contexts to mock out HTTPX responses.","title":"Async Support"},{"location":"versions/0.14.0/mocking/#pytest_1","text":"@respx . mock @pytest . mark . asyncio async def test_something (): async with httpx . AsyncClient () as client : request = respx . get ( \"https://foo.bar/\" , content = \"foobar\" ) response = await client . get ( \"https://foo.bar/\" ) assert request . called assert response . text == \"foobar\" @pytest . mark . asyncio async def test_something (): async with respx . mock : async with httpx . AsyncClient () as client : request = respx . get ( \"https://foo.bar/\" , content = \"foobar\" ) response = await client . get ( \"https://foo.bar/\" ) assert request . called assert response . text == \"foobar\" Session Scoped Fixtures If a session scoped RESPX fixture is used in an async context, you also need to broaden the pytest-asyncio event_loop fixture. You can use the session_event_loop utility for this. # conftest.py import pytest import respx from respx.fixtures import session_event_loop as event_loop # noqa: F401 @pytest . fixture ( scope = \"session\" ) async def mocked_api ( event_loop ): # noqa: F811 async with respx . mock ( base_url = \"https://foo.bar\" ) as respx_mock : ... yield respx_mock","title":"pytest"},{"location":"versions/0.14.0/mocking/#unittest_1","text":"import asynctest class MyTestCase ( asynctest . TestCase ): @respx . mock async def test_something ( self ): async with httpx . AsyncClient () as client : request = respx . get ( \"https://foo.bar/\" , content = \"foobar\" ) response = await client . get ( \"https://foo.bar/\" ) assert request . called assert response . text == \"foobar\" async def test_something ( self ): async with respx . mock : async with httpx . AsyncClient () as client : request = respx . get ( \"https://foo.bar/\" , content = \"foobar\" ) response = await client . get ( \"https://foo.bar/\" ) assert request . called assert response . text == \"foobar\"","title":"unittest"}]}